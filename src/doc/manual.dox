namespace pteros {
/** \page manual Pteros 2.0 user manual

\tableofcontents

\section structure Library structure
\subsection include Include files

\section basic Basic principles

Pteros is developed according to the following principles
- API should be simple and intuitive to use
- Low-level detailes should never be exposed to the user
- Performance should never be compromised
- C++ and Python APIs should be the same except for the language-specific features

Pteros is C++ library with Python bindings. This means that the Python part is only a wrapper over C++ backend. All new features are implemented in C++ and than exposed to Python.

\subsection basic_concepts Basic concepts

\subsubsection atoms Atoms
Pteros treats all particles as atoms. There is no destinction between real atoms and various dummy particles (virtual sites, shell particles, etc.).
Each atom in Pteros has the following attributes:

Property    |   Data type   |   Description |   Comment |
--------    |   ----------- |   ----------- |   ------- |
name        |   string      |   %Atom name   |           |
resid       |   integer     |   Residue id  |   Unique within single protein or nucleic acid chain. May start at any value defined in the structure file for each chain. |
resindex    |   integer     |   Residue index | Unique within the whole system. Chain boundaries are ignored. Starts at 0. Assigned automatically. |
resname     |   string      |   Residue name |          |
chain       |   char        |   Chain identifier | Single character. If no chain information is present defaults to single space.  |
tag         |   string      |   Arbitrary textual tag |   Defaults to empty string |
mass        |   float       |   Atomic mass |   In atomic units. If not given explicitly in the structure file guessed from the atom name. Defaults to 1.0. |
charge      |   float       |   Atomic charge | Electron charge units. Defaults to 0.0. Usually read from topology files. |
beta        |   float       |   PDB B-factor  | Defaults to 0. |
occupancy   |   float       | PDB occupancy facor | Defaults to 0. |
type        |   integer     | Numerical index of atom type |    Defaults to -1, only makes sense in MD topologies.|
type_name   |   string      | Name of atom type | Defaults to empty string. |

\note Coordinates of atoms are stored separately in \ref frame "frames".

Atoms are represented by the objects of Atom class.

\subsubsection system System
The system is a container for atoms, coordinate frames and associated force field parameters. The system may contain many coordinate frames which represent different states of the system (MD time steps or NMR structures for example). System is usually read from one or more structure, trajectory or topology files. Systems are represented by the System class.

\note The system is \em not a representation of particular data file! Although attributes of atoms are similar to the fields of PDB files the system is much more general concept. The system could be constructed from a single file (such as PDB), from several files (such as PDB+XTC) or could be built from scratch programmatically by adding individual atoms and frames.

\subsubsection frame Frame
The frame is representation of the instanteneous state of the system. It contains coordinates of all atoms, time stamp and the periodic box (if the periodic boundary conditions are used). Represented by the Frame class.

\subsubsection selection Selection
Selection is a subset of atoms from particular system. Selection <i>do not contain any data</i> but just points to existing atoms in the system. Selection should be considered as a "handle" to certain group of atoms which allows to query their properties and to manipulate their attributes and coordinates in various ways.

\section load Loading molecular system

\subsection formats Supported file formats

Currently the following file formats are supported:
- Structure files
    + PDB
    + GRO
    + MOL2
- Trajectories
    + XTC
    + TRR
    + TNG
    \note TNG files also contain structure information.
    + DCD
- Topology
    + PTTOP
    \note Read only. Produced from Gromacs TPR files by the `tpr2pteros.py` script.

\subsection types_of_info What is loaded from data files?
Molecular data formats contain different information about the system. In Pteros all information stored in the data files is classified into \em atoms, \em coordinates, \em trajectory and \em topology. Type of particular piece of information is determined by Mol_file_content enum value MFC_* where MFC is abbreviation for "Molecular File Content".
\par Atoms (MFC_ATOMS)
Information about atoms in the system (name, residue name, chain and other attributes) but without coordinates.
\par Coordinates (MFC_COORD)
Single set of coordinates of atoms (single frame) and the periodic box if periodicity is present.
\par Trajectory (MFC_TRAJ)
The number of coordinate frames each containing a set of coordinates, time stamp and the periodic box if periodicity is present.
\par Topology (MFC_TOP)
MD topology containing connectivity, atom types, precise masses, partial charges, non-bond Van-der-Waals parameters, etc.

Particular file format may contain different information. For example PDB files contain atoms and coordinates. XTC files contain the trajectory but no atoms. TNG files contain atoms and trajectory at the same time, etc. There are two ways of loading data files - simple and advanced.

Loading is performed by either constructor of the System class or by System::load() method. In both cases the same behavior and parameters are used.

\subsection simple_load Simple loading

When the data file is loaded in Pteros using simple mode the information being loaded depend on the file type and on the current content of the System where the data go. The most "logical" way of adding new data to the system is chosen but there is no fine control about what is read and how. Here is an example:

\col1
// (1) Initial loading in constructor
System s("somefile.pdb");

// (2) Adding structure file
s.load("other-file.pdb");

// (3) Adding trajectory
s.load("trajectory.xtc",3,20);

// (4) Adding topology
s.load("topology.pttop");
\col2
# Initial loading in constructor
s = System('somefile.pdb')

# (2) Adding structure file
s.load('other-file.pdb')

# (3) Adding trajectory
s.load('trajectory.xtc',3,20)

# (4) Adding topology
s.load('topology.pttop')
\endcol

-# In this example we first construct the System from the PDB file "somefile.pdb". File type is \em always determined by extension. Since on step (1) the system is empty all possible information is read from this file, which means that atoms and coordinates would be read.

-# On step (2) we are adding another PDB file "other-file.pdb". Now the system already contains atoms and one coordinate frame, thus Pteros deduces that we just want to \e add another coordinate frame. Thus only coordinates are read from "other-file.pdb". If the number of atoms in this file is the same as in the System another frame is added. No check is performed if "other-file.pdb" actually contains the same set of atoms as the system - everything with matching number of atoms is accepted.

-# On step (3) we are adding an XTC trajectory. The logic is the same as on step (2) - the number of new coordinate frames are added to the System. Additional arguments instruct Pteros to read frames from 3 to 20 inclusive.

-# Finally on step (4) we are adding topology file. Since the System already contain atoms only additional topological information (like atom types, charges, connectivity, etc.) is read.

Since different file types contain different information the logic of adding information to the System becomes rather complicated in no-trivial situations. The following table summarises what is read from different files in different cases.

<b>Initial loading (in constructor or to the empty System)</b>
File type   |   What is loaded? |   Comment
----------  |   --------------- |   -------
PDB, GRO, MOL2    |   Atoms and the single frame |   MOL2 does not contain periodic box! |
PTTOP   |   Atoms, the single frame, full topology    | PTTOP file is Pteros are not "pure topology" - they also contain the set of starting coordinates.  |
TNG     |   Atoms and multiple frames   |   |
XTC, TRR, DCD   |   Failes and raises exception! | In Pteros reading trajectory into the empty system is not allowed (in contrast to VMD for example). |

<b>Adding data to the System which is not empty (by System::load())</b>
File type   |   What is loaded? |   Comment
----------  |   --------------- |   -------
PDB, GRO, MOL2    |   Single frame |  New frame added. The only check is matching number of atoms.  |
PTTOP   |   Topology    | Adds atom types and charges, updates masses, adds other topology information. No coordinates read, no frames added.  |
TNG, XTC, TRR, DCD   |   Multiple frames | Adds number of new frames. The only check is matching number of atoms. |

\subsection advanced_load Advanced loading with file handlers

\warning Advanced mode should only be used in specific cases and only if you are absolutely sure that you need fine control. The simple mode is the most convenient in most practical scenarios.

\warning Advanced mode and file handlers are \e not available from Python.

In advanced mode the user specifies explicitly what to read and what to store in the system.

\code
#include "pteros/core/mol_file.h"
...
auto pdb_handler = Mol_file::open("some-pdb-file.pdb",'r');
auto gro_handler = Mol_file::open("some-gro-file.gro",'r');
auto xtc_handler = Mol_file::open("some-xtc-file.xtc",'r');

System s;
s.load(pdb_handler, MFC_ATOMS); // (1)
s.load(gro_handler, MFC_COORD); // (2)
// Load frames until the end of trajectory one by one
bool ok;
do {
    ok = s.load(xtc_handler, MFC_TRAJ); // (3)
} while(ok);
\endcode

In this example we first create three file handlers for corresponding PDB, GRO and XTC files. File handlers are created by static Mol_file::open() method. Handlers could be created for reading (mode 'r') and for writing (mode 'w'). In our case we open them for reading. After that we create an empty system and load data from handlers.

-# On step (1) we read only atoms (MFC_ATOMS) from PDB file. No coordinates are read.
-# On step (2) we add coordinates (MFC_COORD) from GRO file.
-# On step (3) we read frames from XTC file (MFC_TRAJ) one by one in the loop up to the end of trajectory. The load() method returns false on failure to read next frame, which allows to track the end of trajectory.

\warning Behavior of MFC_TRAJ for file handlers is different from what is used in simple mode! Each call of `System::load(handler)` reads the \e single frame. This behavior is intentional and allows reading frames one by one.
\note If one will use "MFC_ATOMS | MFC_TRAJ" or "MFC_COORD | MFC_TRAJ" on steps (1) and (2) then MFC_TRAJ will be ignored. This is again intentional to separate frame-by-frame trajectory reading from reading other information.
\warning If MFC_ATOMS is specified the system is cleared before reading even if it already contained some atoms!


\section making_selections Selecting atoms

Selections are the most important objects in Pteros which allow manipulating groups of atoms in the System. It is important to understand that selections do not contain any data but merely point to the set of atoms in the System.

\subsection sel_methods Ways of creating selections

In order to select atoms one need to create Selection class in one of the following ways:

-# <b> Direct construction of Selection object</b>
\col1
Selection sel(system, <arguments...>);
\col2
sel = Selection(system, <arguments...>)
\endcol

-# <b> Construction by System::select() method</b>
\col1
Selection sel = system.select(<arguments...>);
// Or using type inference:
auto sel = system.select(<arguments...>);
\col2
sel = system.select(<arguments...>)
\endcol

-# <b> Construction by System::operator()</b> This is exactly the same as the previous one but less verbose.
\col1
Selection sel = system(<arguments...>);
// Or using type inference:
auto sel = system(<arguments...>);
\col2
sel = system(<arguments...>)
\endcol

\subsection sel_args Arguments of selection methods

The arguments passed to selection could be the following (only method 2 is used for illustration but any method takes the same variants of arguments):

-# <b>Textual selections (using \ref sel_lang "selection language")</b>
\col1
// Defaults to 1st frame in the System
auto sel = system.select("resname ALA GLY and within 3.0 pbc of resid 23-34 45");
// Explicitly points to frame #3
auto sel = system.select("resname ALA GLY and within 3.0 pbc of resid 23-34 45", 3);
\col2
# Defaults to 1st frame in the System
sel = system.select('resname ALA GLY and within 3.0 pbc of resid 23-34 45')
# Explicitly points to frame #3
sel = system.select('resname ALA GLY and within 3.0 pbc of resid 23-34 45', 3)
\endcol

-# <b>Pair of atom indexes</b> Selects atoms with indexes in the given range (inclusive).
\col1
int ind1 = 10;
int ind2 = 20;
sel = system.select(ind1, ind2);
\col2
ind1 = 10
ind2 = 20
sel = system.select(ind1, ind2)
\endcol

-# <b>Vector of atom indexes</b>
\col1
vector<int> ind = {1,2,3,56,67,100};
sel = system.select(ind);
\col2
ind = [1,2,3,56,67,100]
sel = system.select(ind)
\endcol

-# <b>Pair of iterators to integer vector</b>
\warning This is only available in C++.
\code
vector<int> ind = {5,10,34,1,4,15};
Selection sel21(sys,ind.begin(),ind.end());
\endcode

-# <b>Custom callback function</b>
This method allows implementing arbitrary complex logic of selecting atoms by delegating the work to user-provided callback function. The callback function has the following signature:
\col1
void selection_callback(const System& sys, int fr, std::vector<int>& ind);
\col2
def selection_callback(sys, fr, ind)
\endcol
First argument is the parent System, second - is the target frame, and the third is integer vector, which have to be filled with indexes of selected atoms.
The following example shows selecting atoms with x>5. On practice this is easier to implement using textual selections but callback allows implementing arbitrarily complex logic.
\col1
// Callback function
void sel_func(const System& sys,int fr,std::vector<int>& ind){
    // Just for example we are selecting all atoms with x>5
    ind.clear();
    for(int i=0;i<sys.num_atoms();++i)
        if(sys.XYZ(i,fr)(0)>5.0) ind.push_back(i);
}

...

System s("struct.pdb");
// Callback function is called to fill selection
Selection sel(s, &sel_func);
// The same but for specific frame #3
Selection sel(s, &sel_func, 3);
\col2
# Callback function
def sel_func(sys,fr,ind):
    # Just for example we are selecting all atoms with x>5
    ind = []
    for i in xrange(sys.num_atoms()):
        if sys.getXYZ(i,fr)[0]>5.0:
            ind.append(i)

...

s = System('struct.pdb')
# Callback function is called to fill selection
sel = s.select(sel_func)
# The same but for specific frame #3
sel = s.select(sel_func, 3)
\endcol

\subsection sel_modify Modifying selections

Existing selection objects could be modified in two ways: by changing parent System and by selecting another set of atoms. Parent selection is changed by Selection::set_system() method:

\col1
System sys1("structure1.pdb");
System sys2("structure2.pdb");
// Create empty selection pointing to sys1
Selection sel(sys1);
// Make it point to sys2
sel.set_system(sys2);
\col2
sys1 = System('structure1.pdb')
sys2 = System('structure2.pdb')
# Create empty selection pointing to sys1
sel = Selection(sys1)
# Make it point to sys2
sel.set_system(sys2)
\endcol

\warning Selection::set_system() always clears content of selection and leaves it empty even if it contained some data!

In order to modify content of seelction (the set of selected atoms) the number of Selection::modify() methods is present. They accept the same arguments as corresponding constructors of Selection class. Each method also have the variant where new System is passed as the first argument:

-# <b>Textual selections</b>
\col1
// Changes selected atoms
sel.modify("resname ALA GLY");
// The same but also assigns to other system
sel.modify(other_system, "resname ALA GLY");
// The same but also changes the target frame to frame 3
sel.modify(other_system, "resname ALA GLY", 3);
\col2
# Changes selected atoms
sel.modify('resname ALA GLY')
# The same but also assigns to other system
sel.modify(other_system, 'resname ALA GLY')
# The same but also changes the target frame to frame 3
sel.modify(other_system, 'resname ALA GLY', 3)
\endcol

-# <b>Pair of atom indexes</b>
\col1
int ind1 = 10;
int ind2 = 20;
// Changes selected atoms
sel.modify(ind1, ind2);
// The same but also assigns to other system
sel.modify(other_system, ind1, ind2);
\col2
ind1 = 10
ind2 = 20
# Changes selected atoms
sel.modify(ind1, ind2)
# The same but also assigns to other system
sel.modify(other_system, ind1, ind2)
\endcol

-# <b>Vector of atom indexes</b>
\col1
vector<int> ind = {1,2,3,56,67,100};
// Changes selected atoms
sel.modify(ind);
// The same but also assigns to other system
sel.modify(other_system, ind);
\col2
ind = [1,2,3,56,67,100]
# Changes selected atoms
sel.modify(ind)
# The same but also assigns to other system
sel.modify(other_system, ind)
\endcol

-# <b>Pair of iterators to integer vector</b>
\warning This is only available in C++.

\code
vector<int> ind = {5,10,34,1,4,15};
// Changes selected atoms
sel.modify(ind.begin(),ind.end());
// The same but also assigns to other system
sel.modify(other_system, ind.begin(),ind.end());
\endcode

-# <b>Custom callback function</b>
\col1
// Callback function
void sel_func(const System& sys,int fr,std::vector<int>& ind){
    // Just for example we are selecting all atoms with x>5
    ind.clear();
    for(int i=0;i<sys.num_atoms();++i)
        if(sys.XYZ(i,fr)(0)>5.0) ind.push_back(i);
}

...


// Changes selected atoms
sel.modify(sel_func);
// The same but also assigns to other system
sel.modify(other_system, sel_func);
// The same but also changes the target frame to frame 3
sel.modify(other_system, sel_func, 3);
\col2
# Callback function
def sel_func(sys,fr,ind):
    # Just for example we are selecting all atoms with x>5
    ind = []
    for i in xrange(sys.num_atoms()):
        if sys.getXYZ(i,fr)[0]>5.0:
            ind.append(i)

...

# Changes selected atoms
sel.modify(sel_func)
# The same but also assigns to other system
sel.modify(other_system, sel_func)
# The same but also changes the target frame to frame 3
sel.modify(other_system, sel_func, 3)
\endcol

\subsection sel_lang Selection language

%Selection language in Pteros is similar but not identical to one of [VMD](http://www.ks.uiuc.edu/Research/vmd/vmd-1.3/ug/node132.html). Simple selections could be copy-pasted from VMD to Pteros and vice versa, while more complex selections would be different. Particularly Pteros provides much more advanced selections which include periodic boundary conditions, which are not possible in VMD.

The basic elements of selection language are the following:

\subsubsection all_sel Selecting everything
The keyword "all" selects all atoms in the system.

\subsubsection keyword_sel Keyword selections
Consist of the keyword, which represent property of the atom, followed by one or more values of this property. The values are implicitly combined by logical OR. Depending on the keyword the values are either strings, integers or unsigned integers.

For integers in addition to individual values the ranges are allowed in two forms: `1 to 10` and `1-10`. Both forms are equivalent.

For strings regular expressions could be given in single ('') or double ("") quotes. The systnax of the regular expressions is the same [as used in C++11](http://www.cplusplus.com/reference/regex/ECMAScript/).

Keyword | Type of values | Example
------- | -------------- | -------
name    | string    | name CA CB "C.*"
resname | string    | resname ALA GLU '.N.*'
resid   | int   | resid 1 2 3 4-10 20 to 40
resindex | unsigned int | resindex 1 2 3 5 to 100 200-211
chain | single character | chain A B C
tag | string | tag TAG1 TAG2
index | unsigned int | index 12 13 45 2-7


\subsubsection num_prop Numeric properties
Consist of a lone keyword, which represent single numeric property of the atom. Numeric properties could be either integer or floats. They could be combined to \ref num_expr "numerical expressions" and compared by \ref num_comp "numeric comparisons".

Keyword | Property
-----   | -----
x   | X coordinate of the atom
y   | Y coordinate of the atom
z   | Z coordinate of the atom
beta | B-factor of the atom
occupancy | Value of the PDB occupancy field for the atom
index | Index of the atom
resindex | Residue index of the atom
resid | Resid of the atom
distance | The distance of atom from given point, line or plane. See \ref dist_sel "description of distance selections" for details.

\note Words \e index, \e resindex and \e resid could be either keywords followed by multiple values or numeric properties depending on the context:
%Selection string | Interpretation
---- | ----
"resid 1 2 3 4-10" | interpreted as \ref keyword_sel "keyword selection"
"resid > 25" | interpreted as \ref num_prop "numeric property" in \ref num_expr "numerical expression".

\subsubsection num_expr Numeric expressions
Numerical expressions consist of \ref num_prop "numerical properties", integer of float point literals and common arithmetic operators "+", "-", "*", "/". Raising to any integer or fractional power is possible using either "^" or "**" operators. Unary minus could be used to change the sign of expression. Operator precedence could be changed by parentheses. Numerical expressions are only meaningful as operands of \ref num_comp "numeric comparisons". Single number or single numerical property is also valid numerical expression.

\subsubsection num_comp Numeric comparisons

Numerical expressions are compared to each other by the common operators:

Operator | Meaning | Example
-------- | ------- | -------
">" | Greater than | x > 3
"<" | Lower than | y < 5.6
"=" | Equal | resid =  45
"<>" | Not equal | resid <> 14
">=" | Greater or equal | index >= 15
"<=" | Lower or equal | resindex <= 100

The comparisons could be chained to select the ranges:

%Selection text | Meaning
-------------- | -------
3 < x < 10  | Open range
10 > x >= 3 | Semi-closed range
100 <= resid <= 200 | Closed range

\subsubsection log_expr Logical expressions

Common logical operators "or", "and" and "not" are supported and could be used to construct arbitrary logical expressions:
~~~~~
resid 1-10 or x>15
name CA CB and resname ALA
not (name OW and resname SOL and resid > 34)
~~~~~

\subsubsection within_sel Within selections

Within selections allow selecting atoms which are within given cutoff distance around other selection, called "central selection". The syntax of within selections in Pteros is the following:
~~~~
within <distance> [pbc|nopbc|periodic|noperiodic] [self|noself] of <central selection>
~~~~
Distance is in nm.

Optional keywords "pbc" or "periodic" mean that selection takes into account periodic boundary conditions. Keywords "nopbc" or "noperiodic" means that periodicity is switched off. By default periodicity is off.

The optional keyword "self" means that central selection itself is also included into resulting selection. If "noself" is specified the central selection is excluded from result. The default is "self".

Keywords "pbc|nopbc" and "self|noself" can go in any order.

Here are some results:

%Selection text | What is selected
-------------- | ----------------
within 3.0 of protein | All atoms within 3.0 nm from any protein atom including the protein itself. Not periodic.
within 3.0 pbc of protein | Same as above but periodic.
within 3.0 pbc noself of protein | Same as above but the protein itself is not included.

\subsubsection by_res By residue selections

The "by residue <central selection>" operator is used to select whole residues, which are referenced by the central selection. This means that if at least one atom of particular residue is present in central selection then the whole residue would be selected.

\warning The "by residue" operation has lower precedence than logical operators thus its operand have to be put into the parentheses if it contains logical operations: "by residue (name CA and resid 1 4 5)".

\subsubsection dist_sel Distance selections

Distance selections are unique for Pteros and allow selecting atoms by their distance from given reference point, line or plane. Their syntax is the following:
~~~~~
dist|distance point|vector|plane [pbc|nopbc|periodic|noperiodic] x0 y0 z0 [x1 y1 z1]
~~~~~
The keyword "dist" and "distance" are synonyms. If "point" is specified than three float point numbers x0, y0, z0 are expected. For "vector" and "distance" six float point numbers x0, y0, z0, x1, y1, z1 are expected.

Optional keywords "pbc" or "periodic" mean that selection takes into account periodic boundary conditions. Keywords "nopbc" or "noperiodic" means that periodicity is switched off. By default periodicity is off.

In the case of "dist vector" (x0,y0,z0) give the point in space and (x1,y1,z1) specify \b direction of the vector originating from this point (direction is normalized automatically). The distance from the atoms to this vector is evaluated.

In the case of "dist plane" (x0,y0,z0) give the point in space and (x1,y1,z1) specify the <b>normal vector</b> of the plane originating in this point (the normal vector is normalized automatically). The distance from the atoms to this plane is evaluated.

Distance keyword operates on per-atom basis and is treated as \ref num_prop "numeric property" of the atom:

%Selection text | What is selected
-------------- | ----------------
dist point 12.4 34.3 45.1 < 3.0 | Atoms within 3.0 nm from the point "12.4 34.3 45.1"
dist point pbc 12.4 34.3 45.1 < 3.0 | The same as above but periodic
dist vector 2.1 3.3 3.5 1 0 0 < 3.0 | Atoms within the cylinder with radius 3 nm and the axis going from point "2.1 3.3 3.5" along X axis (the direction vector is "1 0 0")
3.0 < dist plane 2.1 3.3 3.5 1 1 1 < 5.0 | Selects the slabs of atoms which are between 3 and 5 nm from the plane which goes through the point "2.1 3.3 3.5" and has the normal "1 1 1".

\subsection text_based_sel Auto-update and flattening of text-based selections
Selections created by means of selection string are a bit special in Pteros. The set of selected may depends on atomic coordinates (for example for selection `x>15` or `within 3.0 of y<34`). These cases are recognized automatically and such coordinate-dependent selection are treated in special manner. If the user calls Selection::set_frame() to change the frame selection points to then selection is recomputed automatically to be consistent with new atomic coordinates.

In most cases this feature is very handy and saves a lot of time allowing not to bother about consistency of the coordinate-dependent selections with the current atomic coordinates. However in certain cases such behavior is not desirable. For example one selects all water molecules around the protein in starting configuration using `resname SOL and within 3.0 of protein` and want to see how they diffuse in the course of MD simulation. Each update of the coordinate frame made by Selection::set_frame() will select new water shell around protein, which is not what we want. In such case one can call Selection::flatten() method. It "flattens" selection to the plain set of indexes without any auto-update magic.
\warning Flattening is not reversible! New text-based selection have to be created to turn auto-update on again.

\subsection sel_comb Combining selections

Selection objects could be combined by logical operations to create new selections:

- <b>Logical AND</b>
\col1
auto new_sel = sel1 & sel2;
\col2
new_sel = sel1 and sel2;
\endcol

- <b>Logical OR</b>
\col1
auto new_sel = sel1 | sel2;
\col2
new_sel = sel1 or sel2;
\endcol

- <b>Logical NOT</b>
\col1
auto new_sel = ~sel1;
\col2
new_sel = not sel2;
\endcol

It is also possible to append one selection to the other using Selection::append() or remove atoms from one selection from the other by Selection::remove(). These methods also work with individual atom indexes.
\warning In contrast to logical operators Selection::append() and Selection::remove() methods do not create new selection but modify existing one.

\subsection access Accessing properties of selected atoms

If selection contains \e N atoms then they could be accessed by relative indexes from 0 to N-1 inclusive. Relative indexes are \e NOT the same as atomic indexes. Atom with global index 150 may have relative index 0 in one selection and 23 in the other. However relative indexes are very convenient in accessing properties of selected atoms. For this Selection class contains the set of <i>accessor methods</i>.

Accessor methos have the same names as the properties of atoms with the first letter capitalized. For example `sel.Index(i)` returns global index of atom with relative index i, `sel.Name(i)` returns name of this atom, `sel.Resname(i)` returns its residue name, etc.

Accessors `X(i)`, `Y(i)` and `Z(i)` give access to individual atomic coordinates. The method `XYZ(i)` returns the vector of all three coordinates. These accessors also accept frame index as optional second parameter: `Z(i,fr)`, `XYZ(i,fr)`, etc.

There are also accessors for periodic box associated with current frame pointed by selection (`Box()`) and the time stamp of the pointed frame (`Time()`).

There is also special accessor `VDW(i)` which returns the van der Waals radius of <i>i</i>-th atom.

There is a difference in behavior of accessors in C++ and Python. In C++ all of them are inlined l-value functions. This means that they do not add any overhead in accessing atom properties and could be assinged to:

\code
Selection sel(system,"name CA");
// Read access
cout << sel.Name(0) << endl;
// Write access
sel.Name(0) = "CB";
\endcode

In Python each accessor have to be prepended by "get" or "set" prefixes for read and write access respectively, which makes them clumsy and difficult to use:

\code{.py}
sel = Selection(system, 'name CA')
# Read access
print sel.getName(0)
# Write access
sel.setName(0, "CB")
\endcode

Much more covenient way of accessing atom properties in Python is using indexing operator of Selection object:

\code{.py}
# Recommended way in Python

sel = Selection(system, 'name CA')
# Read access
print sel[0].name
# Write access
sel[0].name = "CB"
# Note that 'name' is property, not a method!
# It is NOT capitalized and no () is needed!

# This also works for coordinates:
print sel[0].x, sel[0].xyz
sel[0].xyz = sel[1].xyz + sel[2].xyz

# BUT if you want to access coordinates of OTHER frame
# you HAVE to use ordinary accessors:
print sel.getXYZ(0, other_frame)
sel.setXYZ(0, other_frame) = sel[1].xyz + sel[2].xyz
\endcode

Indexing is also perfectly usable in C++ but works slower than accessor methods:
\code
// Works in C++ but not recommended

Selection sel(system,"name CA");
// Read access
cout << sel[0].Name() << endl;
// Write access
sel[0].Name() = "CB";
\endcode

\note The indexing operator of Selection class returns a temporary proxy object Atom_proxy, which has the same set of atom property accessors as Selection itslef. The only difference is that these accessors do not take relative atomic index since Atom_proxy stores it internally. Creation of proxy objects makes iterator access \e slower than access by accessors of selection iteself.

\subsection sel_iter Iterating over selected atoms

There are two ways to iterate over selected atoms - using <i>relative selection indexes</i> and using <i>iterators</i>.

\col1
Selection sel(system, "name CA CB");

// Usage of accessor methods for each atom property
for(int i=0; i< sel.size(); ++i){
    cout << sel.Name(i) << " " << sel.Resname(i) << endl;
}

// Usage of indexing operator (slower than property accessors and not recommended in C++!)
for(int i=0; i< sel.size(); ++i){
    cout << sel[i].name() << " " << sel[i].resname() << endl;
}
\col2
sel = Selection(system, 'name CA CB')

# Usage of accessor methods for each atom property
# (clumsy syntax in Python, not reccomended despite being a bit faster)
for i in xrange(sel.size()):
    print sel.getName(i), sel.getResname(i)

# Usage of indexing operator (still not the best way in Python, see below)
for i in xrange(sel.size()):
    print sel[i].name, sel[i].resname
\endcol

The second way is using built-in iterators of Selection objects:
\col1
Selection sel(system, "name CA CB");

// Usage of explicit iterators
Selection::iterator it;
for(it=sel.begin(); it!=sel.end(); it++){
    cout << it->name() << " " << it->resname() << endl;
}

// Usage of range-based for loop in C++11 and higher
for(auto& a: sel){
    cout << a.name() << " " << a.resname() << endl;
}
\col2
sel = Selection(system, 'name CA CB')

# Recommended way in Python
for a in sel:
    print a.name, a.resname
\endcol

\section sys_build Building molecular systems
\subsection atom_add_del Adding and deleting atoms
\subsection append_remove Appending and removing systems and selections
\subsection distib Multiplying selections
\subsection rearrange Rearranging the order of atoms
*/
}
