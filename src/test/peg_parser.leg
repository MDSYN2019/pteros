%{
#include <iostream>
#include <string>
#include "pteros/core/selection_parser.h"

struct input_data {
    std::string string_to_parse;
    int cur_buf_pos = 0;
    pteros::AstNode_ptr root;
};

#define YY_XTYPE input_data*

#define YY_INPUT(buf, result, max_size, D)        \
{                           \
    if(D->cur_buf_pos==-1){ \
        result=0; \
    } else { \
        int sz; \
        if(D->string_to_parse.size()-D->cur_buf_pos < max_size){ \
            sz = D->string_to_parse.size()-D->cur_buf_pos; \
            D->cur_buf_pos = -1; \
        } else { \
            sz = max_size; \
            D->cur_buf_pos += max_size; \
        } \
        result = sz; \
        memcpy(buf,D->string_to_parse.c_str(),sz); \
    } \
}

#define YYSTYPE pteros::AstNode_ptr

using namespace std;
using namespace pteros;

%}

root_rule = - v:NUM_EXPR !. {cout << "MATCH" << endl; G->data->root = v; }

# Terminals

# Optional space
- = [ \t]*

# Required space
-- = [ \t]+

# Integer number
INT = < ('-'|'+')? [0-9]+ > -
        {
            $$.reset(new AstNode);
            $$->code = TOK_INT;
            $$->children.push_back( atoi(yytext) );
        }

# Float-point number
FLOAT = < (
              ( (('-'|'+')? [0-9]+)? '.' [0-9]+)
            | ( (('-'|'+')? [0-9]+) '.' [0-9]?)
          ) ([eE] (('-'|'+')? [0-9]+))? > -
        {
            $$.reset(new AstNode);
            $$->code = TOK_FLOAT;
            $$->children.push_back( float(atof(yytext)) );
        }

# Rules
NUM_EXPR = l:NUM_TERM
           (
            (
            '+' {
                    auto tmp = AstNode_ptr(new AstNode);
                    l.swap(tmp);
                    l->code = TOK_PLUS;
                    l->children.push_back(tmp);
                }
            -
            |
            '-' {
                    auto tmp = AstNode_ptr(new AstNode);
                    l.swap(tmp);
                    l->code = TOK_MINUS;
                    l->children.push_back(tmp);
                }
            -
            )
           r:NUM_TERM
                {
                    l->children.push_back(r);
                }
           )*
            {
                $$ = l;
            }

NUM_TERM = l:NUM_FACTOR
           (
            (
            '*' {
                    auto tmp = AstNode_ptr(new AstNode);
                    l.swap(tmp);
                    l->code = TOK_MULT;
                    l->children.push_back(tmp);
                }
            -
            |
            '/' {
                    auto tmp = AstNode_ptr(new AstNode);
                    l.swap(tmp);
                    l->code = TOK_DIV;
                    l->children.push_back(tmp);
                }
            -
            )
            r:NUM_FACTOR
                {
                    l->children.push_back(r);
                }
           )*
            {
                $$ = l;
            }

NUM_FACTOR = '(' - NUM_EXPR ')' -
             | FLOAT
             | INT
             | X
             | Y
             | Z
             | BETA
             | OCCUPANCY
             | UNARY_MINUS


UNARY_MINUS = '-'
              v:NUM_FACTOR
                {
                    $$.reset(new AstNode);
                    $$->code = TOK_UNARY_MINUS;
                    $$->children.push_back(v);
                }

X = 'x' -
    {
        $$ = AstNode_ptr(new AstNode);
        $$->code = TOK_X;
    }

Y = 'y' -
    {
        $$ = AstNode_ptr(new AstNode);
        $$->code = TOK_Y;
    }

Z = 'z' -
    {
        $$ = AstNode_ptr(new AstNode);
        $$->code = TOK_Z;
    }

BETA = 'beta' -
    {
        $$ = AstNode_ptr(new AstNode);
        $$->code = TOK_BETA;
    }

OCCUPANCY = 'occupancy' -
    {
        $$ = AstNode_ptr(new AstNode);
        $$->code = TOK_OCC;
    }
